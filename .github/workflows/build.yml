import 'package:flutter/material.dart';
import 'dart:math';
import 'dart:collection'; // For Queue
import 'package:flutter/services.dart'; // For SystemChrome
import 'package:shared_preferences/shared_preferences.dart'; // Ensure this is in your pubspec.yaml

// If you want to play audio, add audioplayers to your pubspec.yaml
// import 'package:audioplayers/audioplayers.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: []); // Hide status and navigation bars
  SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp, // Prefer portrait for this game
  ]).then((_) {
    runApp(const MyApp());
  });
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Bubble Shooter',
      theme: ThemeData(
        brightness: Brightness.dark, // Dark theme for the game
        // If you want to use a custom font like 'Tomorrow', you'll need to add it to your assets
        // and declare it in your pubspec.yaml under the 'flutter: fonts:' section.
        // For now, we'll use the default font.
        // fontFamily: 'Tomorrow',
      ),
      home: const ImageSelectionScreen(), // Start with image selection
    );
  }
}

---

## Image Selection Screen

This screen allows users to "select" their ball images, which are simulated as colors for now. In a real app, you'd integrate an image picker.

```dart
class ImageSelectionScreen extends StatefulWidget {
  const ImageSelectionScreen({super.key});

  @override
  State<ImageSelectionScreen> createState() => _ImageSelectionScreenState();
}

class _ImageSelectionScreenState extends State<ImageSelectionScreen> {
  // Using String? to represent a placeholder for an image path or identifier
  // In a real app, you'd store actual image paths or Base64 strings from a picker.
  final List<String?> _selectedImagePaths = List.filled(4, null);
  final int _requiredImageCount = 4;
  String _errorMessage = '';

  // This method simulates picking an image.
  // In a real application, you would use a package like `image_picker`.
  Future<void> _pickImage(int index) async {
    setState(() {
      // Simulate selecting an image by assigning a placeholder string.
      // This string will be used as the 'type' (mq) for balls in the game.
      // You could use actual asset paths here if your images are bundled as assets.
      _selectedImagePaths[index] = 'ball_type_$index'; // Placeholder for demonstration
      _checkAllImagesLoaded();
    });
  }

  void _checkAllImagesLoaded() {
    final loadedCount = _selectedImagePaths.where((path) => path != null).length;
    if (loadedCount == _requiredImageCount) {
      setState(() {
        _errorMessage = '';
      });
    } else {
      setState(() {
        _errorMessage = 'Please upload ${_requiredImageCount - loadedCount} more photos.';
      });
    }
  }

  Future<void> _startGame() async {
    if (_selectedImagePaths.where((path) => path != null).length == _requiredImageCount) {
      try {
        final prefs = await SharedPreferences.getInstance();
        // Save the list of selected image identifiers.
        // If you were using actual image paths, you'd save those.
        await prefs.setStringList('gameImages', _selectedImagePaths.cast<String>());
        if (mounted) {
          Navigator.pushReplacement(
            context,
            MaterialPageRoute(builder: (context) => const GameScreen()),
          );
        }
      } catch (e) {
        setState(() {
          _errorMessage = "An error occurred: ${e.toString()}";
        });
        debugPrint("LocalStorage error: $e");
      }
    }
  }

  @override
  void initState() {
    super.initState();
    _checkAllImagesLoaded(); // Check on init if any images are pre-selected/loaded
  }

  @override
  Widget build(BuildContext context) {
    final bool allImagesLoaded = _selectedImagePaths.where((path) => path != null).length == _requiredImageCount;

    return Scaffold(
      backgroundColor: const Color.fromARGB(255, 25, 25, 25),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 10, vertical: 20),
              child: Text(
                'SELECT PHOTO OF YOUR BALLS',
                textAlign: TextAlign.center,
                style: TextStyle(
                  fontSize: 1.8 * 16, // Convert em to pixels
                  color: Colors.white,
                  // fontFamily: 'Tomorrow', // Uncomment if font is added
                ),
              ),
            ),
            Wrap(
              spacing: 15,
              runSpacing: 15,
              alignment: WrapAlignment.center,
              children: List.generate(_requiredImageCount, (index) {
                return GestureDetector(
                  onTap: () => _pickImage(index),
                  child: Container(
                    width: 120,
                    height: 120,
                    decoration: BoxDecoration(
                      border: Border.all(
                        color: _selectedImagePaths[index] != null ? Colors.blueAccent : Colors.grey,
                        width: 2,
                        // Corrected: BorderStyle.dashed does not exist, use BorderStyle.solid
                        style: BorderStyle.solid,
                      ),
                      borderRadius: BorderRadius.circular(10),
                      color: Colors.white.withOpacity(0.1),
                    ),
                    child: _selectedImagePaths[index] != null
                        ? const Center(
                          child: Icon(Icons.check_circle, color: Colors.green, size: 50),
                          // In a real app: Image.file(File(_selectedImagePaths[index]!)),
                          // Or a small thumbnail of the picked image.
                          )
                        : Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              const Icon(Icons.add_a_photo, color: Colors.grey),
                              Text(
                                '${index + 1}st Photo',
                                textAlign: TextAlign.center,
                                style: TextStyle(color: Colors.grey, fontSize: 0.75 * 16),
                              ),
                            ],
                          ),
                  ),
                );
              }),
            ),
            Padding(
              padding: const EdgeInsets.only(top: 15.0),
              child: ElevatedButton(
                onPressed: allImagesLoaded ? _startGame : null,
                style: ElevatedButton.styleFrom(
                  backgroundColor: allImagesLoaded ? const Color(0xFF029DFF) : Colors.grey,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 25, vertical: 12),
                  textStyle: const TextStyle(fontSize: 1.3 * 16, /*fontFamily: 'Tomorrow'*/),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
                child: const Text('START GAME'),
              ),
            ),
            if (_errorMessage.isNotEmpty)
              Padding(
                padding: const EdgeInsets.all(15.0),
                child: Text(
                  _errorMessage,
                  textAlign: TextAlign.center,
                  style: TextStyle(color: Colors.orange, fontSize: 0.95 * 16),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

---

## Game Core Logic

This section contains the game objects and the main game screen with its physics and drawing.

```dart
// Define the colors for the balls (replace with actual image data later)
// These colors will act as visual types for the balls.
const List<Color> kBallColors = [
  Colors.red,
  Colors.blue,
  Colors.green,
  Colors.yellow,
  Colors.purple,
  Colors.orange,
  // Add more colors if you expect more than 6 unique types
];

final List<Color> kFrameColors = [
  Colors.yellow,
  Colors.cyan,
  // Corrected: Colors.magenta does not exist. Using a direct Color or Colors.pink.
  const Color(0xFFFF00FF), // This is a common hex for magenta
  Colors.green,
];

Color getFrameColor(int imageIndex) {
  return kFrameColors[imageIndex % kFrameColors.length];
}

class Ball {
  double x, y;
  double radius;
  int type; // mq in JS, represents image/color type
  bool isBooming;
  double nextY; // For smooth sliding/falling
  bool isIsolated;
  double fallSpeed;
  Color borderColor;

  Ball({
    required this.x,
    required this.y,
    required this.radius,
    required this.type,
    this.isBooming = false,
    double? nextY,
    this.isIsolated = false,
    this.fallSpeed = 0.7,
  })  : nextY = nextY ?? y,
        borderColor = getFrameColor(type);

  void fall() {
    if (isIsolated) {
      y += fallSpeed;
    } else if (y < nextY) {
      y = min(nextY, y + GameConstants.slideIncrementPerFrame);
    } else if (y > nextY) {
      y = max(nextY, y - GameConstants.slideIncrementPerFrame);
    }
  }
}

class PlayerBall extends Ball {
  double angle;
  bool isMoving;
  List<Offset> trail;

  PlayerBall({
    required super.x,
    required super.y,
    required super.radius,
    required super.type,
    this.angle = 0,
    this.isMoving = false,
  }) : trail = [];
}

class BoomParticle {
  double x, y;
  double radius;
  double angle;
  Color color;

  BoomParticle({
    required this.x,
    required this.y,
    required this.radius,
    required this.angle,
    required this.color,
  });
}

class GameConstants {
  static double ballRadius = 0; // Will be calculated based on screen width
  static double ballDiameter = 0;
  static double lineEndY = 0; // Game over line
  // No need for slideAmountPerRow here, it's calculated in logic
  static const double slideIncrementPerFrame = 2.0;
  static const int noBoomThreshold = 2; // How many shots without a boom before balls slide down
  static const int explosionThreshold = 5; // Minimum balls to pop
  static const double playerSpeed = 10.0;
  static const double collisionDetectionFactor = 0.95; // For ball-to-ball collision
  static const double hexConnectionThreshold = 1.05; // For checking connected balls
  // hexOccupiedThreshold is not directly used in the current _getNearestHexPosition logic but good to keep in mind for future refinements
  // static const double hexOccupiedThreshold = 0.9;
}

class GameScreen extends StatefulWidget {
  const GameScreen({super.key});

  @override
  State<GameScreen> createState() => _GameScreenState();
}

class _GameScreenState extends State<GameScreen> with SingleTickerProviderStateMixin {
  List<Ball> _dots = [];
  PlayerBall? _player;
  List<BoomParticle> _booms = [];
  bool _gamePlay = true;
  int _score = 0;
  int _highScore = 0;
  bool _isAiming = false;
  Offset? _aimTarget; // Where the user is aiming
  bool _checkBoxAudio = true; // Audio toggle
  int _noBoomStreak = 0;
  bool _slidingInProgress = false;
  int? _lastPoppedImageMq; // Stores the 'type' of the last popped ball group
  int _consecutivePops = 0;
  bool _bigBoomEffect = false;
  double _bigBoomProgress = 0; // For big boom animation
  int _frameCount = 0;
  double _lastTime = 0;
  double _fps = 0;

  late AnimationController _animationController;
  // late AudioPlayer _audioPlayer; // Uncomment and initialize if using audioplayers package

  @override
  void initState() {
    super.initState();
    // _audioPlayer = AudioPlayer(); // Initialize audio player if needed
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(hours: 1), // Long duration for continuous animation
    )..addListener(() {
        _updateGame();
        // Call setState to trigger a repaint only if necessary, or let _updateGame handle it
        setState(() {}); // Rebuild to paint the new state
        _calcFPS();
      });

    _loadGameImagesAndStart();
    _loadHighScore();
  }

  Future<void> _loadGameImagesAndStart() async {
    final prefs = await SharedPreferences.getInstance(); // Corrected usage
    final List<String>? gameImagePaths = prefs.getStringList('gameImages');

    if (gameImagePaths == null || gameImagePaths.length != 4) {
      if (mounted) {
        // Redirect to image selection if images are not set up
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => const ImageSelectionScreen()),
        );
      }
      return;
    }

    // In a real app, you'd load actual images here using gameImagePaths.
    // For this example, `gameImagePaths` values like 'ball_type_0' will be used
    // as integer indices for `kBallColors`.
    // Example: int ballType = int.parse(gameImagePaths[someIndex].split('_').last);

    _newGame();
    _animationController.forward(from: 0.0); // Start the animation
  }

  void _loadHighScore() async {
    final prefs = await SharedPreferences.getInstance(); // Corrected usage
    setState(() {
      _highScore = prefs.getInt('bubbleHighScore') ?? 0;
    });
  }

  @override
  void dispose() {
    _animationController.dispose();
    // _audioPlayer.dispose(); // Dispose audio player if used
    super.dispose();
  }

  void _calcFPS() {
    _frameCount++;
    // Using `_animationController.lastElapsedDuration` can give you the total time since `forward` was called.
    // To get delta time between frames, you might want to use `SchedulerBinding.instance.addPostFrameCallback`.
    // For simplicity, a basic time check is used here.
    final now = DateTime.now().millisecondsSinceEpoch.toDouble();
    if (_lastTime == 0) {
      _lastTime = now;
    }
    final dt = (now - _lastTime) / 1000.0; // convert milliseconds to seconds
    if (dt >= 1.0) { // Update FPS roughly every second
      setState(() {
        _fps = _frameCount / dt;
      });
      _lastTime = now;
      _frameCount = 0;
    }
  }

  void _updateGame() {
    if (!_gamePlay) return;

    // Update player ball position
    if (_player != null && _player!.isMoving) {
      _player!.x += GameConstants.playerSpeed * cos(_player!.angle);
      _player!.y += GameConstants.playerSpeed * sin(_player!.angle);

      // Add to trail
      _player!.trail.add(Offset(_player!.x, _player!.y));
      if (_player!.trail.length > 20) {
        _player!.trail.removeAt(0);
      }

      // Wall collision
      if (_player!.x - _player!.radius < 0) {
        _player!.x = _player!.radius;
        _player!.angle = pi - _player!.angle;
      } else if (_player!.x + _player!.radius > MediaQuery.of(context).size.width) {
        _player!.x = MediaQuery.of(context).size.width - _player!.radius;
        _player!.angle = pi - _player!.angle;
      }

      // Check for collisions with other balls or ceiling
      _checkPlayerCollision();
    }

    // Update and remove boom particles
    _booms.removeWhere((boom) {
      boom.x += 2 * cos(boom.angle);
      boom.y += 2 * sin(boom.angle);
      boom.radius -= 0.5;
      return boom.radius <= 0.6;
    });

    // Update fall animation for balls
    for (var ball in _dots) {
      ball.fall();
    }

    // Update big boom animation progress
    if (_bigBoomEffect) {
      _bigBoomProgress += 15; // Speed of expansion
      if (_bigBoomProgress > max(MediaQuery.of(context).size.width, MediaQuery.of(context).size.height) * 0.7) {
        _bigBoomEffect = false;
        _bigBoomProgress = 0;
      }
    }

    // Check for end game conditions
    _checkEndGame();
  }

  void _checkPlayerCollision() {
    if (_player == null) return;

    bool hitOccurred = false;

    // Ceiling collision
    if (_player!.y <= _player!.radius) {
      hitOccurred = true;
      _stopPlayerBall(_player!.x, _player!.radius);
    }

    if (!hitOccurred) {
      for (int i = 0; i < _dots.length; i++) {
        final dot = _dots[i];
        if (dot.isBooming) continue; // Skip balls already marked for boom

        final distance = sqrt(pow(_player!.x - dot.x, 2) + pow(_player!.y - dot.y, 2));
        final collisionThreshold = (_player!.radius + dot.radius) * GameConstants.collisionDetectionFactor;

        if (distance < collisionThreshold) {
          hitOccurred = true;
          // Find the best hexagonal position around the hit dot
          // This is a simplified version; in complex cases, you might iterate neighbors.
          Offset bestPosition = _getNearestHexPosition(_player!.x, _player!.y);

          _stopPlayerBall(bestPosition.dx, bestPosition.dy);
          break; // Collision detected, stop checking
        }
      }
    }
  }

  void _stopPlayerBall(double finalX, double finalY) {
    if (_player == null) return;
    _player!.isMoving = false;
    _player!.x = finalX;
    _player!.y = finalY;
    _player!.trail.clear(); // Clear trail once ball stops

    // Add player ball to dots list
    final newDot = Ball(
      x: _player!.x,
      y: _player!.y,
      radius: _player!.radius,
      type: _player!.type,
    );
    _dots.add(newDot);

    // Perform color check (same as checkColor in JS)
    _checkConnectedBalls(newDot);
  }

  Offset _getNearestHexPosition(double x, double y) {
    final double rowHeight = GameConstants.ballDiameter * sqrt(3) / 2;
    final double colWidth = GameConstants.ballDiameter;

    // Calculate approximate row and column
    int targetRow = ((y - GameConstants.ballRadius) / rowHeight).round();

    // Determine row offset for staggered columns
    double rowOffset = (targetRow % 2 == 0) ? 0 : GameConstants.ballRadius;

    int targetCol = ((x - GameConstants.ballRadius - rowOffset) / colWidth).round();

    // Calculate precise x and y for the center of the hexagonal cell
    double nearestX = GameConstants.ballRadius + targetCol * colWidth + rowOffset;
    double nearestY = GameConstants.ballRadius + targetRow * rowHeight;

    // Ensure position is within canvas bounds
    nearestX = nearestX.clamp(GameConstants.ballRadius, MediaQuery.of(context).size.width - GameConstants.ballRadius);
    nearestY = nearestY.clamp(GameConstants.ballRadius, MediaQuery.of(context).size.height - GameConstants.ballRadius);

    return Offset(nearestX, nearestY);
  }

  void _checkConnectedBalls(Ball newDot) {
    List<Ball> connectedGroup = [];
    Set<Ball> visited = {};
    Queue<Ball> queue = Queue();

    queue.add(newDot);
    visited.add(newDot);
    connectedGroup.add(newDot);

    while (queue.isNotEmpty) {
      final currentDot = queue.removeFirst();

      for (var neighborDot in _dots) {
        if (currentDot != neighborDot &&
            currentDot.type == neighborDot.type &&
            !visited.contains(neighborDot)) {
          final distance = sqrt(pow(currentDot.x - neighborDot.x, 2) + pow(currentDot.y - neighborDot.y, 2));
          if (distance < (currentDot.radius + neighborDot.radius) * GameConstants.hexConnectionThreshold) {
            queue.add(neighborDot);
            visited.add(neighborDot);
            connectedGroup.add(neighborDot);
          }
        }
      }
    }

    if (connectedGroup.length >= GameConstants.explosionThreshold) {
      _handleBoomEffect(connectedGroup, newDot.type);
      _noBoomStreak = 0;
    } else {
      // No boom, reset boom status for these balls
      for (var ball in connectedGroup) {
        ball.isBooming = false;
      }
      _playAudio('soundball');
      _lastPoppedImageMq = null;
      _consecutivePops = 0;
      _noBoomStreak++;
      if (!_slidingInProgress) {
        _handleNoBoomEffect();
      }
    }

    _prepareNextPlayer();
  }

  void _handleBoomEffect(List<Ball> poppedBalls, int poppedMq) {
    if (_lastPoppedImageMq == null || _lastPoppedImageMq != poppedMq) {
      _lastPoppedImageMq = poppedMq;
      _consecutivePops = 1;
    } else if (_lastPoppedImageMq == poppedMq) {
      _consecutivePops++;
    }

    // Use a temporary list to avoid modifying _dots while iterating
    List<Ball> dotsToRemove = [];
    for (var ballToBoom in poppedBalls) {
      // Create boom particles
      for (int n = 0; n < 10; n++) {
        _booms.add(BoomParticle(
          x: ballToBoom.x,
          y: ballToBoom.y,
          radius: ballToBoom.radius / 2,
          angle: Random().nextDouble() * 2 * pi,
          color: kBallColors[ballToBoom.type], // Use the ball's color
        ));
      }
      dotsToRemove.add(ballToBoom); // Mark for removal
      _score++;
    }
    _dots.removeWhere((dot) => dotsToRemove.contains(dot)); // Remove all marked balls

    _checkIsolatedBalls(); // Check for isolated balls after a pop

    if (poppedBalls.length > 6) { // Big boom for large pops
      _bigBoomEffect = true;
      _score += 10; // Bonus points
      _playAudio('soundbigboom');
      // Animation progress will be handled in _updateGame
    } else {
      _playAudio('soundboom');
    }
  }

  void _handleNoBoomEffect() {
    if (_noBoomStreak >= GameConstants.noBoomThreshold && !_slidingInProgress) {
      _slidingInProgress = true;
      final slideAmount = GameConstants.ballDiameter * sqrt(3) / 2; // Slide by one full row height

      for (var dot in _dots) {
        dot.nextY += slideAmount;
      }

      _noBoomStreak = 0;

      // Estimate duration for slide animation to complete
      final slideDuration = Duration(milliseconds: (slideAmount / GameConstants.slideIncrementPerFrame * (1000 / 60)).round());
      Future.delayed(slideDuration, () {
        _slidingInProgress = false;
      });
    }
  }

  void _prepareNextPlayer() {
    _newPlayer();
    double maxDotY = 0;
    if (_dots.isNotEmpty) {
      maxDotY = _dots.map((dot) => dot.y + dot.radius).reduce(max);
    }

    if (maxDotY >= GameConstants.lineEndY - GameConstants.ballDiameter * 1.5) {
      // Shift all existing dots down by one row height
      for (var dot in _dots) {
        dot.nextY += GameConstants.ballDiameter * sqrt(3) / 2;
      }
      // Add new row after a short delay for smooth transition
      Future.delayed(const Duration(milliseconds: 15), () {
        _addNewRow();
      });
    }
  }

  void _addNewRow() {
    double currentYForNewRow = GameConstants.ballRadius;
    if (_dots.isNotEmpty) {
      // Find the Y of the highest existing ball to determine where the new row starts
      currentYForNewRow = _dots.map((dot) => dot.y).reduce(min) - GameConstants.ballDiameter * sqrt(3) / 2;
    }

    final int estimatedRowNumber = ((currentYForNewRow - GameConstants.ballRadius) / (GameConstants.ballDiameter * sqrt(3) / 2)).round();
    final double nextRowOffset = (estimatedRowNumber % 2 == 0) ? 0 : GameConstants.ballRadius;

    double startX = GameConstants.ballRadius + nextRowOffset;

    for (double x = startX; x < MediaQuery.of(context).size.width - GameConstants.ballRadius; x += GameConstants.ballDiameter) {
      // Ensure the generated ball type (index) is within the bounds of kBallColors
      int randomBallType = Random().nextInt(kBallColors.length);
      _dots.add(Ball(x: x, y: currentYForNewRow, radius: GameConstants.ballRadius, type: randomBallType));
    }
  }

  void _checkIsolatedBalls() {
    for (var dot in _dots) {
      dot.isIsolated = false; // Reset isolation status
    }

    Set<Ball> connectedToTop = {};
    Queue<Ball> q = Queue();

    // Start BFS from balls at the very top
    for (var dot in _dots) {
      if (!dot.isBooming && dot.y <= GameConstants.ballRadius * 1.1) {
        q.add(dot);
        connectedToTop.add(dot);
      }
    }

    while (q.isNotEmpty) {
      final current = q.removeFirst();

      for (var neighbor in _dots) {
        if (current != neighbor && !connectedToTop.contains(neighbor) && !neighbor.isBooming) {
          final distance = sqrt(pow(current.x - neighbor.x, 2) + pow(current.y - neighbor.y, 2));
          if (distance < GameConstants.ballDiameter * GameConstants.hexConnectionThreshold) {
            q.add(neighbor);
            connectedToTop.add(neighbor);
          }
        }
      }
    }

    int fallCount = 0;
    // Use a temporary list to avoid modifying _dots while iterating
    List<Ball> isolatedBallsToRemove = [];
    for (var dot in _dots) {
      if (!connectedToTop.contains(dot) && !dot.isBooming) {
        dot.isIsolated = true;
        dot.nextY = MediaQuery.of(context).size.height + dot.radius; // Target to fall off screen
        dot.fallSpeed = 7; // Faster fall speed
        fallCount++;
        isolatedBallsToRemove.add(dot); // Mark for removal after falling off screen
      }
    }
    _score += fallCount; // Add points for falling balls
    // Note: Actual removal of falling balls happens in _checkEndGame when they are off-screen
  }

  void _checkEndGame() {
    // Remove isolated balls once they are completely off screen
    _dots.removeWhere((dot) => dot.y > MediaQuery.of(context).size.height + dot.radius && dot.isIsolated);

    for (var dot in _dots) {
      // Game ends if any non-isolated ball reaches or crosses the end line
      if (dot.y + dot.radius >= GameConstants.lineEndY && !dot.isIsolated) {
        _gamePlay = false;
        _endGame();
        break;
      }
    }
  }

  void _endGame() async {
    _playAudio('soundend');
    _animationController.stop(); // Stop the game loop

    final prefs = await SharedPreferences.getInstance(); // Corrected usage
    if (_score > _highScore) {
      _highScore = _score;
      await prefs.setInt('bubbleHighScore', _highScore);
    }

    // Show End Game UI using showDialog
    showDialog(
      context: context,
      barrierDismissible: false, // User must tap button to dismiss
      builder: (BuildContext context) {
        return AlertDialog(
          backgroundColor: Colors.black54,
          title: const Text('GAME OVER!', textAlign: TextAlign.center, style: TextStyle(color: Colors.white, fontSize: 28)),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text('Score: $_score', style: const TextStyle(color: Colors.white, fontSize: 24)),
              const SizedBox(height: 10),
              Text(
                _score > _highScore ? 'New High Score: $_highScore' : 'High Score: $_highScore',
                style: TextStyle(color: _score > _highScore ? Colors.yellow : Colors.white, fontSize: 18),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop(); // Close the dialog
                _newGame(); // Start a new game
                _animationController.forward(from: 0.0); // Restart animation
              },
              child: const Text('PLAY AGAIN', style: TextStyle(color: Colors.blueAccent, fontSize: 20)),
            ),
          ],
        );
      },
    );
  }

  void _newGame() {
    setState(() {
      _dots = [];
      _booms = [];
      _score = 0;
      _gamePlay = true;
      _noBoomStreak = 0;
      _slidingInProgress = false;
      _lastPoppedImageMq = null;
      _consecutivePops = 0;
      _bigBoomEffect = false;
      _bigBoomProgress = 0;
      _fps = 0; // Reset FPS display
    });

    _initGameDimensions(); // Re-initialize dimensions
    _createInitialBalls(); // Create initial balls for the new game
    _newPlayer(); // Create initial player ball for the new game
  }

  void _initGameDimensions() {
    // Ensure this is called after the context is available and size is known
    final Size size = MediaQuery.of(context).size;
    GameConstants.ballRadius = size.width / 16 - 0.01;
    GameConstants.ballDiameter = GameConstants.ballRadius * 2;
    GameConstants.lineEndY = size.height - 1.7 * GameConstants.ballDiameter;
  }

  void _createInitialBalls() {
    double currentY = GameConstants.ballRadius;
    for (int r = 0; r < 6; r++) { // Create initial 6 rows of balls
      double rowXOffset = (r % 2 == 0) ? 0 : GameConstants.ballRadius; // Staggered rows
      for (double x = GameConstants.ballRadius + rowXOffset; x < MediaQuery.of(context).size.width - GameConstants.ballRadius; x += GameConstants.ballDiameter) {
        // Ensure the generated ball type (index) is within the bounds of kBallColors
        int randomBallType = Random().nextInt(kBallColors.length);
        _dots.add(Ball(
          x: x,
          y: currentY,
          radius: GameConstants.ballRadius,
          type: randomBallType, // Random ball type (color)
        ));
      }
      currentY += GameConstants.ballDiameter * sqrt(3) / 2; // Move to next row's Y position
    }
  }

  void _newPlayer() {
    // Random ball type for player ball, using an index into kBallColors
    int playerMq = Random().nextInt(kBallColors.length);
    // If consecutive pops of the same image, give player that image type
    if (_consecutivePops >= 2 && _lastPoppedImageMq != null) {
      playerMq = _lastPoppedImageMq!;
      _consecutivePops = 0;
      _lastPoppedImageMq = null;
    }
    setState(() {
      _player = PlayerBall(
        x: MediaQuery.of(context).size.width / 2,
        y: MediaQuery.of(context).size.height - GameConstants.ballRadius * 2,
        radius: GameConstants.ballRadius,
        type: playerMq,
      );
    });
  }

  void _playAudio(String soundName) {
    if (_checkBoxAudio) {
      // In a real Flutter app, use audioplayers package:
      // First, add 'audioplayers: ^x.x.x' to your pubspec.yaml.
      // Then, add your audio files (e.g., soundball.mp3) to an 'assets/audio/' folder
      // and declare them in pubspec.yaml under 'flutter: assets:'.
      // Finally, you can play them like this:
      // AudioCache().play('audio/$soundName.mp3');
      debugPrint('Playing sound: $soundName (Audio playback not fully implemented without `audioplayers` package)');
    }
  }

  @override
  Widget build(BuildContext context) {
    // Initialize game dimensions only after the build method gives us the context/size
    // This is often done once in initState or in the first build cycle.
    if (GameConstants.ballRadius == 0) { // Check if dimensions are not yet set
      _initGameDimensions();
      _createInitialBalls();
      _newPlayer();
    }

    return Scaffold(
      backgroundColor: const Color.fromARGB(255, 25, 25, 25),
      body: GestureDetector(
        onPanDown: (details) {
          if (_player != null && !_player!.isMoving && _gamePlay) {
            setState(() {
              _isAiming = true;
              _aimTarget = details.localPosition;
            });
          }
        },
        onPanUpdate: (details) {
          if (_player != null && _isAiming && !_player!.isMoving && _gamePlay) {
            setState(() {
              _aimTarget = details.localPosition;
            });
          }
        },
        onPanEnd: (details) {
          if (_player != null && _isAiming && !_player!.isMoving && _gamePlay) {
            if (_aimTarget != null && _player != null) {
              final dx = _player!.x - _aimTarget!.dx;
              final dy = _player!.y - _aimTarget!.dy;
              _player!.angle = atan2(-dy, -dx); // Calculate angle
              _player!.isMoving = true;
              _player!.trail.clear(); // Clear trail on new shot
              _playAudio('soundselect'); // Play sound on shoot
            }
            setState(() {
              _isAiming = false;
              _aimTarget = null;
            });
          }
        },
        child: Stack(
          children: [
            CustomPaint(
              painter: GamePainter(
                dots: _dots,
                player: _player,
                booms: _booms,
                isAiming: _isAiming,
                aimTarget: _aimTarget,
                lineEndY: GameConstants.lineEndY,
                bigBoomEffect: _bigBoomEffect,
                bigBoomProgress: _bigBoomProgress,
              ),
              size: Size.infinite,
            ),
            Positioned(
              top: 20,
              left: 20,
              child: Text(
                'Score: $_score',
                style: const TextStyle(color: Colors.white, fontSize: 24, fontWeight: FontWeight.bold, /*fontFamily: 'Tomorrow'*/),
              ),
            ),
            Positioned(
              bottom: 20,
              left: 20,
              child: Text(
                'High Score: $_highScore',
                style: const TextStyle(color: Colors.yellow, fontSize: 18, /*fontFamily: 'Tomorrow'*/),
              ),
            ),
            Positioned(
              bottom: 10,
              right: 10,
              child: Column(
                children: [
                  Text(
                    'FPS: ${_fps.toStringAsFixed(0)}',
                    style: const TextStyle(color: Colors.white, fontSize: 12),
                  ),
                  IconButton(
                    icon: Icon(
                      _checkBoxAudio ? Icons.volume_up : Icons.volume_off,
                      color: Colors.white,
                      size: 24,
                    ),
                    onPressed: () {
                      setState(() {
                        _checkBoxAudio = !_checkBoxAudio;
                      });
                    },
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class GamePainter extends CustomPainter {
  final List<Ball> dots;
  final PlayerBall? player;
  final List<BoomParticle> booms;
  final bool isAiming;
  final Offset? aimTarget;
  final double lineEndY;
  final bool bigBoomEffect;
  final double bigBoomProgress;

  GamePainter({
    required this.dots,
    required this.player,
    required this.booms,
    required this.isAiming,
    required this.aimTarget,
    required this.lineEndY,
    required this.bigBoomEffect,
    required this.bigBoomProgress,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // Draw game over line
    final Paint linePaint = Paint()
      ..color = Colors.white.withOpacity(0.8)
      ..strokeWidth = 2;
    canvas.drawLine(Offset(0, lineEndY), Offset(size.width, lineEndY), linePaint);

    // Draw existing balls
    for (var dot in dots) {
      final Paint ballPaint = Paint()..color = kBallColors[dot.type];
      canvas.drawCircle(Offset(dot.x, dot.y), dot.radius, ballPaint);

      // Draw border
      final Paint borderPaint = Paint()
        ..color = dot.borderColor
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2;
      canvas.drawCircle(Offset(dot.x, dot.y), dot.radius, borderPaint);

      // Placeholder for image drawing (if you load actual images)
      // If you have `ui.Image` objects loaded:
      // final Rect srcRect = Rect.fromLTWH(0, 0, image.width.toDouble(), image.height.toDouble());
      // final Rect destRect = Rect.fromCircle(center: Offset(dot.x, dot.y), radius: dot.radius);
      // canvas.drawImageRect(image, srcRect, destRect, Paint());
    }

    // Draw player ball
    if (player != null) {
      // Draw trail
      for (int i = 0; i < player!.trail.length; i++) {
        final trailDot = player!.trail[i];
        final ratio = i / player!.trail.length;
        final alpha = ratio * 0.7; // Trail becomes more transparent
        final sizeReduction = (1 - ratio) * 0.7; // Trail becomes smaller

        final Paint trailPaint = Paint()..color = Colors.white.withOpacity(alpha);
        canvas.drawCircle(trailDot, player!.radius * (1 - sizeReduction), trailPaint);
      }

      final Paint playerPaint = Paint()..color = kBallColors[player!.type];
      canvas.drawCircle(Offset(player!.x, player!.y), player!.radius, playerPaint);

      // Draw border for player ball
      final Paint playerBorderPaint = Paint()
        ..color = player!.borderColor
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2;
      canvas.drawCircle(Offset(player!.x, player!.y), player!.radius, playerBorderPaint);

      // Draw aiming line
      if (isAiming && aimTarget != null) {
        final Paint aimLinePaint = Paint()
          ..color = Colors.white.withOpacity(0.8)
          ..strokeWidth = 1;
        canvas.drawLine(Offset(player!.x, player!.y), aimTarget!, aimLinePaint);
      }
    }

    // Draw boom particles
    for (var boom in booms) {
      final Paint boomPaint = Paint()..color = boom.color;
      canvas.drawCircle(Offset(boom.x, boom.y), boom.radius, boomPaint);
    }

    // Draw big boom effect
    if (bigBoomEffect) {
      // These rings expand from the center of the screen
      final double centerX = size.width / 2;
      final double centerY = size.height / 2;

      _drawBlastRings(canvas, centerX, centerY, bigBoomProgress, 10, Colors.white);
      _drawBlastRings(canvas, centerX, centerY, bigBoomProgress - 30, 15, Colors.yellow);
      _drawBlastRings(canvas, centerX, centerY, bigBoomProgress - 50, 20, Colors.orange);
      _drawBlastRings(canvas, centerX, centerY, bigBoomProgress - 100, 30, Colors.red);
      // For particle effect in Flutter, you would typically manage a list of particle objects
      // and draw them here similar to how booms are handled.
    }
  }

  void _drawBlastRings(Canvas canvas, double x, double y, double radius, double strokeWidth, Color color) {
    if (radius < 0) radius = 0; // Ensure radius doesn't go negative
    final Paint paint = Paint()
      ..color = color
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke;
    canvas.drawCircle(Offset(x, y), radius + 30, paint); // Offset radius slightly for visual effect
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) {
    // Repaint whenever the state changes to update the game graphics.
    // For a game, this usually means `true` to ensure smooth animation.
    return true;
  }
}
